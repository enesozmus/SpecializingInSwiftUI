<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20240506T143250Z" application="Evernote" version="10.86.8">
  <note>
    <title>Declaring a custom view and Adding the to the view hierarchy</title>
    <created>20240506T130719Z</created>
    <updated>20240506T142841Z</updated>
    <note-attributes>
      <author>Enes Ozmus</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>  We define views and assemble them into a view hierarchy.</div><div>  <b>SwiftUI</b> offers <span style="font-size: 14px;"><i>a declarative approach</i></span> to user interface design.</div><div>  <b>SwiftUI</b> provides tools for defining and configuring the views in your user interface.</div><div>  You compose custom views out of built-in views that <b>SwiftUI</b> provides, plus other composite views that you’ve already defined.</div><div>  You configure these views with view modifiers and connect them to your data model.</div><div>  You then place your custom views within your app’s view hierarchy.</div><div><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>struct MyView: View {</div><div>}</div></div><div>  You can declare <span style="color:rgb(182, 41, 212);">a custom view</span> type by defining a structure that conforms to <b><span style="color:rgb(26, 169, 178);">the View protocol</span></b>.</div><div style="padding-left:80px;">  Like other Swift protocols, <b><span style="color:rgb(26, 169, 178);">the View protocol</span></b> provides a blueprint for functionality — in this case, the behavior of an element that SwiftUI draws onscreen.</div><div style="padding-left:80px;">  Conformance to the protocol comes with both requirements that a view must fulfill, and functionality that the protocol provides.</div><div>  After you fulfill the requirements, you can insert your custom view into a view hierarchy so that it becomes part of your app’s user interface.</div><div><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>struct MyView: View {</div><div>    var body: some View {</div><div>    }</div><div>}</div></div><div>  <b><span style="color:rgb(26, 169, 178);">The View protocol’s</span></b> main requirement is that conforming types must define <i><span style="color:rgb(24, 168, 65);">a body computed property</span></i>.</div><div style="padding-left:80px;">  The value that the view returns is an element that SwiftUI draws onscreen.</div><div style="padding-left:80px;">  SwiftUI reads the value of this property any time it needs to update the view, which can happen repeatedly during the life of the view, typically in response to user input or system events.</div><div>  <b><span style="color:rgb(26, 169, 178);">The View protocol’s</span></b> secondary requirement is that conforming types must indicate <span style="color:rgb(229, 158, 37);">an associated type</span> <i><span style="color:rgb(24, 168, 65);">for the body property</span></i>. However, you don’t make an explicit declaration.</div><div>  Instead, you declare <i><span style="color:rgb(24, 168, 65);">the body property</span></i> as an opaque type, using the <code>: some View</code>syntax, to indicate only that the body’s type conforms to View.</div><div>  <i><u>The exact type</u></i> depends on the body’s content, which varies as you edit the body during development. Swift infers the exact type automatically.</div><div style="padding-left:80px;">↓ <span style="color:rgb(229, 158, 37);">Associated Types</span> ↓</div><div style="padding-left:120px;">  When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition.</div><div style="padding-left:120px;">  An associated type gives a placeholder name to a type that’s used as part of the protocol.</div><div style="padding-left:120px;">  The actual type to use for that associated type isn’t specified until the protocol is adopted.</div><div style="padding-left:120px;"><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>struct MyView: View {</div><div>    var body: some View {</div><div>        VStack {</div><div>            Text("Hello, World!")</div><div>            Text("Glad to meet you.")</div><div>        }</div><div>    }</div><div>}</div></div><div>  Describe your view’s appearance by adding content to the view’s body property.</div><div style="padding-left:80px;">  SwiftUI also provides built-in views that you can use to arrange other views.</div><div style="padding-left:80px;">  For example, you can vertically stack two Text views using a VStack.</div><div style="padding-left:80px;">  Views that take multiple input child views, like the stack in the example above, typically do so using a closure marked with the <code>ViewBuilder</code>attribute.</div><div style="padding-left:80px;"><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>struct MyView: View {</div><div>    var body: some View {</div><div>        VStack {</div><div>            Text("Hello, World!")</div><div>                .font(.title)</div><div>            Text("Glad to meet you.")</div><div>        }</div><div>    }</div><div>}</div></div><div>  To configure the views in your view’s body, you apply <span style="--en-highlight:purple;background-color: #cbcaff;">view modifiers</span>.</div><div style="padding-left:80px;">  A modifier is nothing more than a method called on a particular view.</div><div style="padding-left:80px;">  The method returns a new, altered view that effectively takes the place of the original in the view hierarchy.</div><div style="padding-left:80px;">  SwiftUI extends the View protocol with a large set of methods for this purpose.</div><div style="padding-left:80px;">  If an input value changes, SwiftUI notices the change and redraws only the affected parts of your interface. This might involve reinitializing your entire view, but SwiftUI manages that for you.</div><div style="padding-left:80px;"><br/></div><div style="--en-codeblock:true; --en-lineWrapping:false;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>struct ContentView: View {</div><div>    var body: some View {</div><div>        MyView(helloFont: .title)</div><div>    }</div><div>}</div></div><div>  After you define a view, you can incorporate it in other views, just like you do with built-in views.</div><hr/><div><a href="https://medium.com/@ozcanahmet/programming-paradigms-in-swift-comparing-imperative-and-declarative-approaches-2659fa246b17">https://medium.com/@ozcanahmet/programming-paradigms-in-swift-comparing-imperative-and-declarative-approaches-2659fa246b17</a></div><div>https://medium.com/macoclock/imperative-vs-declarative-programming-swift-fa538e01a7ba</div><h3 style="--en-isCollapsed:false; --en-nodeId:1d78917b-8ddf-4ed1-9773-14408edc844f;"><i>imperative approach &amp; declarative approach </i></h3><ul style="--en-todo:true;"><ul style="--en-todo:true;"><li style="--en-checked:false;"><div><span style="font-size: 14px;"><i>  <span style="color:rgb(24, 133, 226);">imperative approach</span> → </i></span> Stand up, walk until you reach the door, open the door, exit the office, take the lift, exit the building, enter the supermarket, buy the bottle of water.</div></li><li style="--en-checked:false;"><div><span style="font-size: 14px;"><i>  <span style="color:rgb(182, 41, 212);">declarative approach</span></i></span> → Please buy a bottle of water for me.</div></li><ul style="--en-todo:true;"><li style="--en-checked:false;"><div>  As you can see, the imperative approach is about <b>HOW</b> he will get you water, while the declarative approach is about <b>WHAT</b> you want!.</div></li></ul></ul></ul><div><br/></div><div>  In imperative programming, Swift allows you to specify a sequence of steps to achieve a task, and you control the flow of execution explicitly using statements like loops and conditionals.</div><div>  You focus on detailing how to perform a specific task step by step.</div><div>  Imperative programming in Swift is commonly used when you need fine-grained control over mutable state and explicit control flow.</div><div><br/></div><div>  In declarative programming, Swift allows you to define what you want to achieve without specifying how to achieve it.</div><div>  You declare the desired outcome, and Swift or its libraries handle the implementation details.</div><div>  Declarative programming in Swift is often associated with frameworks like SwiftUI for building user interfaces or using functional programming concepts.</div><div>  Declarative programming is a method to abstract the control flow for logic required for software to perform an action.</div><div><br/></div><div><b>Differences:</b></div><div style="padding-left:40px;">Control Flow:</div><ul style="--en-todo:true;"><ul style="--en-todo:true;"><ul><li><div>  In imperative programming, you have explicit control over the flow of execution through loops, conditionals, and function calls.</div></li><li><div>  In declarative programming, control flow is often abstracted away or handled by the framework or language features, making the code more concise and focusing on what needs to be done.</div></li></ul></ul></ul><div style="padding-left:40px;">Mutable State:</div><ul style="--en-todo:true;"><ul style="--en-todo:true;"><ul><li><div>  Imperative programming often involves mutable state, where variables can be modified during execution.</div></li><li><div>  Declarative programming tends to emphasize immutability and statelessness, which can lead to safer and more predictable code.</div></li></ul></ul></ul><div style="padding-left:40px;">Readability:</div><ul style="--en-todo:true;"><ul style="--en-todo:true;"><ul><li><div>  Declarative code is often more readable and expressive because it focuses on the intent or desired outcome rather than the implementation details.</div></li><li><div>  Imperative code may require more mental effort to understand due to the explicit control flow and mutable state changes.</div></li></ul></ul></ul><div style="padding-left:40px;">Concurrency:</div><ul style="--en-todo:true;"><ul style="--en-todo:true;"><ul><li><div>  Declarative code can be more amenable to concurrent and parallel programming because it emphasizes immutability and avoids shared mutable state.</div></li><li><div>  Imperative code may require careful synchronization to handle concurrency properly.</div></li></ul></ul></ul></en-note>      ]]>
    </content>
  </note>
</en-export>
